{"version":3,"sources":["../src/Btc.js"],"names":["addressFormatMap","legacy","p2sh","bech32","MAX_SCRIPT_BLOCK","DEFAULT_VERSION","DEFAULT_LOCKTIME","DEFAULT_SEQUENCE","SIGHASH_ALL","OP_DUP","OP_HASH160","HASH_SIZE","OP_EQUALVERIFY","OP_CHECKSIG","Btc","transport","scrambleKey","decorateAppAPIMethods","buffer","update","digest","path","options","verify","format","Error","paths","p1","p2","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","publicKeyLength","response","addressLength","publicKey","slice","toString","bitcoinAddress","chainCode","opts","arguments","console","warn","getWalletPublicKey_private","transactionData","indexLookup","data","firstRound","prefix","concat","trustedInput","transaction","additionals","version","inputs","outputs","locktime","isDecred","includes","isXST","processScriptBlocks","script","sequence","scriptBlocks","offset","blockSize","push","getTrustedInputRaw","scriptBlock","processWholeScriptBlock","block","processInputs","isXSTV2","compare","from","treeField","input","tree","prevout","createVarint","processOutputs","output","amount","finalData","timestamp","sha","serializeTransaction","hash","writeUInt32LE","newTransaction","bip143","overwinter","nVersionGroupId","startUntrustedHashTransactionInputRaw","i","value","outputScript","lockTime","sigHashType","expiryHeight","pathsBuffer","lockTimeBuffer","result","messageHex","message","toSend","maxChunkSize","chunkSize","writeUInt16BE","copy","v","r","s","associatedKeysets","changePath","outputScriptHex","segwit","initialTimestamp","hasTimestamp","undefined","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","resuming","targetTransaction","getTrustedInputCall","getTrustedInputBIP143","bind","getTrustedInput","nExpiryHeight","extraData","compressPublicKey","Math","floor","startUntrustedHashTransactionInput","provideOutputFullChangePath","hashOutputFull","signTransaction","hashPublicKey","pseudoTX","Object","assign","pseudoTrustedInputs","signature","witness","signatureSize","keySize","tmpScriptData","decredWitness","inputIndex","transactionVersion","prefixBuffer","transactionHex","isSegwitSupported","hasExtraData","equals","varint","getVarint","numberInputs","numberOutputs","witnessScript","outputBuffer","skipWitness","isBech32","inputBuffer","useWitness","serializeTransactionOutputs","log"],"mappings":"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","file":"Btc.js","sourcesContent":["//@flow\n\n// TODO future refactoring\n// - drop utils.js & refactoring with async/await style\n// - try to avoid every place we do hex<>Buffer conversion. also accept Buffer as func parameters (could accept both a string or a Buffer in the API)\n// - there are redundant code across apps (see Eth vs Btc). we might want to factorize it somewhere. also each app apdu call should be abstracted it out as an api\nimport { foreach, doIf, asyncWhile, splitPath, eachSeries } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport createHash from \"create-hash\";\n\n/**\n * address format is one of legacy | p2sh | bech32\n */\nexport type AddressFormat = \"legacy\" | \"p2sh\" | \"bech32\";\n\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2\n};\n\nconst MAX_SCRIPT_BLOCK = 50;\nconst DEFAULT_VERSION = 1;\nconst DEFAULT_LOCKTIME = 0;\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst SIGHASH_ALL = 1;\nconst OP_DUP = 0x76;\nconst OP_HASH160 = 0xa9;\nconst HASH_SIZE = 0x14;\nconst OP_EQUALVERIFY = 0x88;\nconst OP_CHECKSIG = 0xac;\n/**\n * Bitcoin API.\n *\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc(transport)\n */\nexport default class Btc {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"BTC\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessageNew\",\n        \"createPaymentTransactionNew\"\n      ],\n      scrambleKey\n    );\n  }\n\n  hashPublicKey(buffer: Buffer) {\n    return createHash(\"rmd160\")\n      .update(\n        createHash(\"sha256\")\n          .update(buffer)\n          .digest()\n      )\n      .digest();\n  }\n\n  getWalletPublicKey_private(\n    path: string,\n    options: {\n      verify?: boolean,\n      format?: AddressFormat\n    } = {}\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    const { verify, format } = {\n      verify: false,\n      format: \"legacy\",\n      ...options\n    };\n    if (!(format in addressFormatMap)) {\n      throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n    }\n    const paths = splitPath(path);\n    var p1 = verify ? 1 : 0;\n    var p2 = addressFormatMap[format];\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x40, p1, p2, buffer).then(response => {\n      const publicKeyLength = response[0];\n      const addressLength = response[1 + publicKeyLength];\n      const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      const bitcoinAddress = response\n        .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n        .toString(\"ascii\");\n      const chainCode = response\n        .slice(\n          1 + publicKeyLength + 1 + addressLength,\n          1 + publicKeyLength + 1 + addressLength + 32\n        )\n        .toString(\"hex\");\n      return { publicKey, bitcoinAddress, chainCode };\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 173' paths\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?:\n      | boolean\n      | {\n          verify?: boolean,\n          format?: AddressFormat\n        }\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    let options;\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\n        \"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\"\n      );\n      options = {\n        verify: !!opts,\n        format: arguments[2] ? \"p2sh\" : \"legacy\"\n      };\n    } else {\n      options = opts || {};\n    }\n    return this.getWalletPublicKey_private(path, options);\n  }\n\n  getTrustedInputRaw(\n    transactionData: Buffer,\n    indexLookup: ?number\n  ): Promise<string> {\n    let data;\n    let firstRound = false;\n    if (typeof indexLookup === \"number\") {\n      firstRound = true;\n      const prefix = Buffer.alloc(4);\n      prefix.writeUInt32BE(indexLookup, 0);\n      data = Buffer.concat(\n        [prefix, transactionData],\n        transactionData.length + 4\n      );\n    } else {\n      data = transactionData;\n    }\n    return this.transport\n      .send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data)\n      .then(trustedInput =>\n        trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\")\n      );\n  }\n\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ): Promise<string> {\n    const { version, inputs, outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    const isXST = additionals.includes(\"stealthcoin\");\n    const processScriptBlocks = (script, sequence) => {\n      const scriptBlocks = [];\n      let offset = 0;\n      while (offset !== script.length) {\n        let blockSize =\n          script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : script.length - offset;\n        if (offset + blockSize !== script.length) {\n          scriptBlocks.push(script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([script.slice(offset, offset + blockSize), sequence])\n          );\n        }\n        offset += blockSize;\n      }\n\n      // Handle case when no script length: we still want to pass the sequence\n      // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n      if (script.length === 0) {\n        scriptBlocks.push(sequence);\n      }\n\n      return eachSeries(scriptBlocks, scriptBlock =>\n        this.getTrustedInputRaw(scriptBlock)\n      );\n    };\n\n    const processWholeScriptBlock = block => this.getTrustedInputRaw(block);\n\n    const processInputs = () => {\n      return eachSeries(inputs, input => {\n        const isXSTV2 =\n          isXST &&\n          Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n        const treeField = isDecred\n          ? input.tree || Buffer.from([0x00])\n          : Buffer.alloc(0);\n        const data = Buffer.concat([\n          input.prevout,\n          treeField,\n          isXSTV2 ? Buffer.from([0x00]) : this.createVarint(input.script.length)\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"input\");\n          // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n          return isDecred\n            ? processWholeScriptBlock(\n                Buffer.concat([input.script, input.sequence])\n              )\n            : isXSTV2\n            ? processWholeScriptBlock(input.sequence)\n            : processScriptBlocks(input.script, input.sequence);\n        });\n      }).then(() => {\n        const data = this.createVarint(outputs.length);\n        return this.getTrustedInputRaw(data);\n      });\n    };\n\n    const processOutputs = () =>\n      eachSeries(outputs, output => {\n        let data = output.amount;\n        data = Buffer.concat([\n          data,\n          isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"output\");\n        });\n      }).then(() => {\n        //Add expiry height for decred\n        const finalData = isDecred\n          ? Buffer.concat([locktime, Buffer.from([0x00, 0x00, 0x00, 0x00])])\n          : locktime;\n        return this.getTrustedInputRaw(finalData);\n      });\n\n    const data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      this.createVarint(inputs.length)\n    ]);\n    return this.getTrustedInputRaw(data, indexLookup)\n      .then(processInputs)\n      .then(processOutputs);\n  }\n\n  async getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ) {\n    if (!transaction) {\n      throw new Error(\"getTrustedInputBIP143: missing tx\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    if (isDecred) {\n      throw new Error(\"Decred does not implement BIP143\");\n    }\n    let sha = createHash(\"sha256\");\n    sha.update(this.serializeTransaction(transaction, true));\n    let hash = sha.digest();\n    sha = createHash(\"sha256\");\n    sha.update(hash);\n    hash = sha.digest();\n    const data = Buffer.alloc(4);\n    data.writeUInt32LE(indexLookup, 0);\n    const { outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n    }\n    if (!outputs[indexLookup]) {\n      throw new Error(\"getTrustedInputBIP143: wrong index\");\n    }\n    hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n    return await hash.toString(\"hex\");\n  }\n\n  getVarint(data: Buffer, offset: number): [number, number] {\n    if (data[offset] < 0xfd) {\n      return [data[offset], 1];\n    }\n    if (data[offset] === 0xfd) {\n      return [(data[offset + 2] << 8) + data[offset + 1], 3];\n    }\n    if (data[offset] === 0xfe) {\n      return [\n        (data[offset + 4] << 24) +\n          (data[offset + 3] << 16) +\n          (data[offset + 2] << 8) +\n          data[offset + 1],\n        5\n      ];\n    }\n\n    throw new Error(\"getVarint called with unexpected parameters\");\n  }\n\n  startUntrustedHashTransactionInputRaw(\n    newTransaction: boolean,\n    firstRound: boolean,\n    transactionData: Buffer,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    const p2 = bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n        ? 0x04\n        : 0x02\n      : 0x00;\n    return this.transport.send(\n      0xe0,\n      0x44,\n      firstRound ? 0x00 : 0x80,\n      newTransaction ? p2 : 0x80,\n      transactionData\n    );\n  }\n\n  startUntrustedHashTransactionInput(\n    newTransaction: boolean,\n    transaction: Transaction,\n    inputs: Array<{ trustedInput: boolean, value: Buffer }>,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    let data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length)\n    ]);\n    return this.startUntrustedHashTransactionInputRaw(\n      newTransaction,\n      true,\n      data,\n      bip143,\n      overwinter,\n      additionals\n    ).then(() => {\n      let i = 0;\n      const isDecred = additionals.includes(\"decred\");\n      return eachSeries(transaction.inputs, input => {\n        let prefix;\n        if (bip143) {\n          prefix = Buffer.from([0x02]);\n        } else {\n          if (inputs[i].trustedInput) {\n            prefix = Buffer.from([0x01, inputs[i].value.length]);\n          } else {\n            prefix = Buffer.from([0x00]);\n          }\n        }\n        data = Buffer.concat([\n          prefix,\n          inputs[i].value,\n          isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n          this.createVarint(input.script.length)\n        ]);\n        return this.startUntrustedHashTransactionInputRaw(\n          newTransaction,\n          false,\n          data,\n          bip143,\n          overwinter,\n          additionals\n        ).then(() => {\n          let scriptBlocks = [];\n          let offset = 0;\n          if (input.script.length === 0) {\n            scriptBlocks.push(input.sequence);\n          } else {\n            while (offset !== input.script.length) {\n              let blockSize =\n                input.script.length - offset > MAX_SCRIPT_BLOCK\n                  ? MAX_SCRIPT_BLOCK\n                  : input.script.length - offset;\n              if (offset + blockSize !== input.script.length) {\n                scriptBlocks.push(\n                  input.script.slice(offset, offset + blockSize)\n                );\n              } else {\n                scriptBlocks.push(\n                  Buffer.concat([\n                    input.script.slice(offset, offset + blockSize),\n                    input.sequence\n                  ])\n                );\n              }\n              offset += blockSize;\n            }\n          }\n          return eachSeries(scriptBlocks, scriptBlock => {\n            return this.startUntrustedHashTransactionInputRaw(\n              newTransaction,\n              false,\n              scriptBlock,\n              bip143,\n              overwinter,\n              additionals\n            );\n          }).then(() => {\n            i++;\n          });\n        });\n      });\n    });\n  }\n\n  provideOutputFullChangePath(path: string): Promise<string> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n  }\n\n  hashOutputFull(\n    outputScript: Buffer,\n    additionals: Array<string> = []\n  ): Promise<*> {\n    let offset = 0;\n    let p1 = 0x80;\n    const isDecred = additionals.includes(\"decred\");\n    ///WARNING: Decred works only with one call (without chunking)\n    //TODO: test without this for Decred\n    if (isDecred) {\n      return this.transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n    }\n    return asyncWhile(\n      () => offset < outputScript.length,\n      () => {\n        let blockSize =\n          offset + MAX_SCRIPT_BLOCK >= outputScript.length\n            ? outputScript.length - offset\n            : MAX_SCRIPT_BLOCK;\n        let p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n        let data = outputScript.slice(offset, offset + blockSize);\n\n        return this.transport.send(0xe0, 0x4a, p1, 0x00, data).then(() => {\n          offset += blockSize;\n        });\n      }\n    );\n  }\n\n  signTransaction(\n    path: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    expiryHeight?: Buffer,\n    additionals: Array<string> = []\n  ): Promise<Buffer> {\n    const isDecred = additionals.includes(\"decred\");\n    const paths = splitPath(path);\n    let offset = 0;\n    const pathsBuffer = Buffer.alloc(paths.length * 4);\n    paths.forEach(element => {\n      pathsBuffer.writeUInt32BE(element, offset);\n      offset += 4;\n    });\n    const lockTimeBuffer = Buffer.alloc(4);\n    lockTimeBuffer.writeUInt32BE(lockTime, 0);\n    let buffer = isDecred\n      ? Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          lockTimeBuffer,\n          expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n          Buffer.from([sigHashType])\n        ])\n      : Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          Buffer.from([0x00]),\n          lockTimeBuffer,\n          Buffer.from([sigHashType])\n        ]);\n    if (expiryHeight && !isDecred) {\n      buffer = Buffer.concat([buffer, expiryHeight]);\n    }\n    return this.transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n      if (result.length > 0) {\n        result[0] = 0x30;\n        return result.slice(0, result.length - 2);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessageNew_async(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessageNew(\n    path: string,\n    messageHex: string\n  ): Promise<{ v: number, r: string, s: string }> {\n    const paths = splitPath(path);\n    const message = new Buffer(messageHex, \"hex\");\n    let offset = 0;\n    const toSend = [];\n    while (offset !== message.length) {\n      let maxChunkSize =\n        offset === 0\n          ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4\n          : MAX_SCRIPT_BLOCK;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      const buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 2,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport.send(0xe0, 0x4e, 0x00, i === 0 ? 0x01 : 0x80, data)\n    ).then(() => {\n      return this.transport\n        .send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]))\n        .then(response => {\n          const v = response[0] - 0x30;\n          let r = response.slice(4, 4 + response[3]);\n          if (r[0] === 0) {\n            r = r.slice(1);\n          }\n          r = r.toString(\"hex\");\n          let offset = 4 + response[3] + 2;\n          let s = response.slice(offset, offset + response[offset - 1]);\n          if (s[0] === 0) {\n            s = s.slice(1);\n          }\n          s = s.toString(\"hex\");\n          return { v, r, s };\n        });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createPaymentTransactionNew with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.createPaymentTransactionNew(\n   [ [tx1, 1] ],\n   [\"0'/0/0\"],\n   undefined,\n   \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n ).then(res => ...);\n   */\n  createPaymentTransactionNew(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    changePath?: string,\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    initialTimestamp?: number,\n    additionals: Array<string> = [],\n    expiryHeight?: Buffer\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    const isXST = additionals.includes(\"stealthcoin\");\n    const hasTimestamp = initialTimestamp !== undefined;\n    let startTime = Date.now();\n    const sapling = additionals.includes(\"sapling\");\n    const bech32 = segwit && additionals.includes(\"bech32\");\n    let useBip143 =\n      segwit ||\n      (!!additionals &&\n        (additionals.includes(\"abc\") ||\n          additionals.includes(\"gold\") ||\n          additionals.includes(\"bip143\"))) ||\n      (!!expiryHeight && !isDecred);\n    // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    !!expiryHeight && !isDecred\n      ? defaultVersion.writeUInt32LE(sapling ? 0x80000004 : 0x80000003, 0)\n      : isXST\n      ? defaultVersion.writeUInt32LE(2, 0)\n      : defaultVersion.writeUInt32LE(1, 0); // Default version to 2 for XST not to have timestamp\n    const trustedInputs: Array<*> = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    const publicKeys = [];\n    let firstRun = true;\n    const resuming = false;\n    const targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion,\n      timestamp: Buffer.alloc(0)\n    };\n    const getTrustedInputCall = useBip143\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input => {\n      return doIf(!resuming, () => {\n        return getTrustedInputCall(input[1], input[0], additionals).then(\n          trustedInput => {\n            let sequence = Buffer.alloc(4);\n            sequence.writeUInt32LE(\n              input.length >= 4 && typeof input[3] === \"number\"\n                ? input[3]\n                : DEFAULT_SEQUENCE,\n              0\n            );\n            trustedInputs.push({\n              trustedInput: true,\n              value: Buffer.from(trustedInput, \"hex\"),\n              sequence\n            });\n          }\n        );\n      })\n        .then(() => {\n          const { outputs } = input[0];\n          const index = input[1];\n          if (outputs && index <= outputs.length - 1) {\n            regularOutputs.push(outputs[index]);\n          }\n        })\n        .then(() => {\n          if (!!expiryHeight && !isDecred) {\n            targetTransaction.nVersionGroupId = Buffer.from(\n              sapling ? [0x85, 0x20, 0x2f, 0x89] : [0x70, 0x82, 0xc4, 0x03]\n            );\n            targetTransaction.nExpiryHeight = expiryHeight;\n            // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n            // Overwinter : use nJoinSplit (1)\n            targetTransaction.extraData = Buffer.from(\n              sapling\n                ? [\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00\n                  ]\n                : [0x00]\n            );\n          } else if (isDecred) {\n            targetTransaction.nExpiryHeight = expiryHeight;\n          }\n        });\n    })\n      .then(() => {\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(!resuming, () =>\n          // Collect public keys\n          foreach(inputs, (input, i) =>\n            this.getWalletPublicKey_private(associatedKeysets[i])\n          ).then(result => {\n            for (let index = 0; index < result.length; index++) {\n              publicKeys.push(\n                this.compressPublicKey(\n                  Buffer.from(result[index].publicKey, \"hex\")\n                )\n              );\n            }\n          })\n        )\n      )\n      .then(() => {\n        if (hasTimestamp) {\n          targetTransaction.timestamp = Buffer.alloc(4);\n          targetTransaction.timestamp.writeUInt32LE(\n            Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n            0\n          );\n        }\n      })\n      .then(() =>\n        doIf(useBip143, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true,\n            !!expiryHeight,\n            additionals\n          ).then(() =>\n            doIf(!resuming && typeof changePath != \"undefined\", () => {\n              // $FlowFixMe\n              return this.provideOutputFullChangePath(changePath);\n            }).then(() => this.hashOutputFull(outputScript))\n          )\n        )\n      )\n      .then(() =>\n        doIf(!!expiryHeight && !isDecred, () =>\n          // FIXME: I think we should always pass lockTime here.\n          this.signTransaction(\"\", lockTime, SIGHASH_ALL, expiryHeight)\n        )\n      )\n      .then(() =>\n        // Do the second run with the individual transaction\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : !segwit\n              ? regularOutputs[i].script\n              : Buffer.concat([\n                  Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n                  this.hashPublicKey(publicKeys[i]),\n                  Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG])\n                ]);\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = useBip143\n            ? [trustedInputs[i]]\n            : trustedInputs;\n          if (useBip143) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !useBip143 && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            useBip143,\n            !!expiryHeight && !isDecred,\n            additionals\n          )\n            .then(() =>\n              doIf(!useBip143, () =>\n                doIf(!resuming && typeof changePath != \"undefined\", () => {\n                  // $FlowFixMe\n                  return this.provideOutputFullChangePath(changePath);\n                }).then(() => this.hashOutputFull(outputScript, additionals))\n              )\n            )\n            .then(() => {\n              return this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType,\n                expiryHeight,\n                additionals\n              );\n            })\n            .then(signature => {\n              signatures.push(signature);\n              targetTransaction.inputs[i].script = nullScript;\n              if (firstRun) {\n                firstRun = false;\n              }\n            });\n        })\n      )\n      .then(() => {\n        // Populate the final input scripts\n        for (let i = 0; i < inputs.length; i++) {\n          if (segwit) {\n            targetTransaction.witness = Buffer.alloc(0);\n            if (!bech32) {\n              targetTransaction.inputs[i].script = Buffer.concat([\n                Buffer.from(\"160014\", \"hex\"),\n                this.hashPublicKey(publicKeys[i])\n              ]);\n            }\n          } else {\n            const signatureSize = Buffer.alloc(1);\n            const keySize = Buffer.alloc(1);\n            signatureSize[0] = signatures[i].length;\n            keySize[0] = publicKeys[i].length;\n            targetTransaction.inputs[i].script = Buffer.concat([\n              signatureSize,\n              signatures[i],\n              keySize,\n              publicKeys[i]\n            ]);\n          }\n          let offset = useBip143 ? 0 : 4;\n          targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(\n            offset,\n            offset + 0x24\n          );\n        }\n\n        const lockTimeBuffer = Buffer.alloc(4);\n        lockTimeBuffer.writeUInt32LE(lockTime, 0);\n\n        var result = Buffer.concat([\n          this.serializeTransaction(\n            targetTransaction,\n            false,\n            targetTransaction.timestamp,\n            additionals\n          ),\n          outputScript\n        ]);\n\n        if (segwit && !isDecred) {\n          var witness = Buffer.alloc(0);\n          for (var i = 0; i < inputs.length; i++) {\n            var tmpScriptData = Buffer.concat([\n              Buffer.from(\"02\", \"hex\"),\n              Buffer.from([signatures[i].length]),\n              signatures[i],\n              Buffer.from([publicKeys[i].length]),\n              publicKeys[i]\n            ]);\n            witness = Buffer.concat([witness, tmpScriptData]);\n          }\n          result = Buffer.concat([result, witness]);\n        }\n\n        // FIXME: In ZEC or KMD sapling lockTime is serialized before expiryHeight.\n        // expiryHeight is used only in overwinter/sapling so I moved lockTimeBuffer here\n        // and it should not break other coins because expiryHeight is false for them.\n        // Don't know about Decred though.\n        result = Buffer.concat([result, lockTimeBuffer]);\n\n        if (expiryHeight) {\n          result = Buffer.concat([\n            result,\n            targetTransaction.nExpiryHeight || Buffer.alloc(0),\n            targetTransaction.extraData || Buffer.alloc(0)\n          ]);\n        }\n\n        if (isDecred) {\n          let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n          inputs.forEach((input, inputIndex) => {\n            decredWitness = Buffer.concat([\n              decredWitness,\n              Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n              Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n              Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n              Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n              targetTransaction.inputs[inputIndex].script\n            ]);\n          });\n\n          result = Buffer.concat([result, decredWitness]);\n        }\n\n        return result.toString(\"hex\");\n      });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.signP2SHTransaction(\n [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n [\"0'/0/0\"],\n \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n).then(result => ...);\n   */\n  signP2SHTransaction(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    transactionVersion?: number = DEFAULT_VERSION\n  ) {\n    // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    defaultVersion.writeUInt32LE(transactionVersion, 0);\n    const trustedInputs = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    let firstRun = true;\n    const resuming = false;\n    let targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion\n    };\n\n    const getTrustedInputCall = segwit\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input =>\n      doIf(!resuming, () =>\n        getTrustedInputCall(input[1], input[0]).then(trustedInput => {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            input.length >= 4 && typeof input[3] === \"number\"\n              ? input[3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          trustedInputs.push({\n            trustedInput: false,\n            value: segwit\n              ? Buffer.from(trustedInput, \"hex\")\n              : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n            sequence\n          });\n        })\n      ).then(() => {\n        const { outputs } = input[0];\n        const index = input[1];\n        if (outputs && index <= outputs.length - 1) {\n          regularOutputs.push(outputs[index]);\n        }\n      })\n    )\n      .then(() => {\n        // Pre-build the target transaction\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(segwit, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true\n          ).then(() => this.hashOutputFull(outputScript))\n        )\n      )\n      .then(() =>\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : regularOutputs[i].script;\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n          if (segwit) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !segwit && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            segwit\n          )\n            .then(() => doIf(!segwit, () => this.hashOutputFull(outputScript)))\n            .then(() =>\n              this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType\n              ).then(signature => {\n                signatures.push(\n                  segwit\n                    ? signature.toString(\"hex\")\n                    : signature.slice(0, signature.length - 1).toString(\"hex\")\n                );\n                targetTransaction.inputs[i].script = nullScript;\n                if (firstRun) {\n                  firstRun = false;\n                }\n              })\n            );\n        })\n      )\n      .then(() => signatures);\n  }\n\n  compressPublicKey(publicKey: Buffer): Buffer {\n    const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n    const prefixBuffer = Buffer.alloc(1);\n    prefixBuffer[0] = prefix;\n    return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n  }\n\n  createVarint(value: number): Buffer {\n    if (value < 0xfd) {\n      const buffer = Buffer.alloc(1);\n      buffer[0] = value;\n      return buffer;\n    }\n    if (value <= 0xffff) {\n      const buffer = Buffer.alloc(3);\n      buffer[0] = 0xfd;\n      buffer[1] = value & 0xff;\n      buffer[2] = (value >> 8) & 0xff;\n      return buffer;\n    }\n    const buffer = Buffer.alloc(5);\n    buffer[0] = 0xfe;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    buffer[3] = (value >> 16) & 0xff;\n    buffer[4] = (value >> 24) & 0xff;\n    return buffer;\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: ?boolean = false,\n    hasTimestamp?: boolean = false,\n    hasExtraData?: boolean = false,\n    additionals: Array<string> = []\n  ): Transaction {\n    const inputs = [];\n    const outputs = [];\n    var witness = false;\n    let offset = 0;\n    let timestamp = Buffer.alloc(0);\n    let nExpiryHeight = Buffer.alloc(0);\n    let nVersionGroupId = Buffer.alloc(0);\n    let extraData = Buffer.alloc(0);\n    const isDecred = additionals.includes(\"decred\");\n    const transaction = Buffer.from(transactionHex, \"hex\");\n    const version = transaction.slice(offset, offset + 4);\n    const overwinter =\n      version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n      version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80]));\n    offset += 4;\n    if (\n      !hasTimestamp &&\n      isSegwitSupported &&\n      transaction[offset] === 0 &&\n      transaction[offset + 1] !== 0\n    ) {\n      offset += 2;\n      witness = true;\n    }\n    if (hasTimestamp) {\n      timestamp = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    if (overwinter) {\n      nVersionGroupId = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    let varint = this.getVarint(transaction, offset);\n    const numberInputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberInputs; i++) {\n      const prevout = transaction.slice(offset, offset + 36);\n      offset += 36;\n      let script = Buffer.alloc(0);\n      let tree = Buffer.alloc(0);\n      //No script for decred, it has a witness\n      if (!isDecred) {\n        varint = this.getVarint(transaction, offset);\n        offset += varint[1];\n        script = transaction.slice(offset, offset + varint[0]);\n        offset += varint[0];\n      } else {\n        //Tree field\n        tree = transaction.slice(offset, offset + 1);\n        offset += 1;\n      }\n\n      const sequence = transaction.slice(offset, offset + 4);\n      offset += 4;\n      inputs.push({ prevout, script, sequence, tree });\n    }\n    varint = this.getVarint(transaction, offset);\n    const numberOutputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberOutputs; i++) {\n      const amount = transaction.slice(offset, offset + 8);\n      offset += 8;\n\n      if (isDecred) {\n        //Script version\n        offset += 2;\n      }\n\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      outputs.push({ amount, script });\n    }\n    let witnessScript, locktime;\n    if (witness) {\n      witnessScript = transaction.slice(offset, -4);\n      locktime = transaction.slice(transaction.length - 4);\n    } else {\n      locktime = transaction.slice(offset, offset + 4);\n    }\n    offset += 4;\n    if (overwinter || isDecred) {\n      nExpiryHeight = transaction.slice(offset, offset + 4);\n      offset += 4;\n    }\n    if (hasExtraData) {\n      extraData = transaction.slice(offset);\n    }\n\n    //Get witnesses for Decred\n    if (isDecred) {\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      if (varint[0] !== numberInputs) {\n        throw new Error(\"splitTransaction: incoherent number of witnesses\");\n      }\n      for (let i = 0; i < numberInputs; i++) {\n        //amount\n        offset += 8;\n        //block height\n        offset += 4;\n        //block index\n        offset += 4;\n        //Script size\n        varint = this.getVarint(transaction, offset);\n        offset += varint[1];\n        const script = transaction.slice(offset, offset + varint[0]);\n        offset += varint[0];\n        inputs[i].script = script;\n      }\n    }\n\n    return {\n      version,\n      inputs,\n      outputs,\n      locktime,\n      witness: witnessScript,\n      timestamp,\n      nVersionGroupId,\n      nExpiryHeight,\n      extraData\n    };\n  }\n\n  /**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n    let outputBuffer = Buffer.alloc(0);\n    if (typeof outputs !== \"undefined\") {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        this.createVarint(outputs.length)\n      ]);\n      outputs.forEach(output => {\n        outputBuffer = Buffer.concat([\n          outputBuffer,\n          output.amount,\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n      });\n    }\n    return outputBuffer;\n  }\n\n  /**\n   */\n  serializeTransaction(\n    transaction: Transaction,\n    skipWitness: boolean,\n    timestamp?: Buffer,\n    additionals: Array<string> = []\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    const isBech32 = additionals.includes(\"bech32\");\n    let inputBuffer = Buffer.alloc(0);\n    let useWitness =\n      typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n    transaction.inputs.forEach(input => {\n      inputBuffer =\n        isDecred || isBech32\n          ? Buffer.concat([\n              inputBuffer,\n              input.prevout,\n              Buffer.from([0x00]), //tree\n              input.sequence\n            ])\n          : Buffer.concat([\n              inputBuffer,\n              input.prevout,\n              this.createVarint(input.script.length),\n              input.script,\n              input.sequence\n            ]);\n    });\n\n    let outputBuffer = this.serializeTransactionOutputs(transaction);\n    if (\n      typeof transaction.outputs !== \"undefined\" &&\n      typeof transaction.locktime !== \"undefined\"\n    ) {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        (useWitness && transaction.witness) || Buffer.alloc(0),\n        transaction.locktime,\n        transaction.nExpiryHeight || Buffer.alloc(0),\n        transaction.extraData || Buffer.alloc(0)\n      ]);\n    }\n\n    return Buffer.concat([\n      transaction.version,\n      timestamp ? timestamp : Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer\n    ]);\n  }\n\n  /**\n   */\n  displayTransactionDebug(transaction: Transaction) {\n    console.log(\"version \" + transaction.version.toString(\"hex\"));\n    transaction.inputs.forEach((input, i) => {\n      const prevout = input.prevout.toString(\"hex\");\n      const script = input.script.toString(\"hex\");\n      const sequence = input.sequence.toString(\"hex\");\n      console.log(\n        `input ${i} prevout ${prevout} script ${script} sequence ${sequence}`\n      );\n    });\n    (transaction.outputs || []).forEach((output, i) => {\n      const amount = output.amount.toString(\"hex\");\n      const script = output.script.toString(\"hex\");\n      console.log(`output ${i} amount ${amount} script ${script}`);\n    });\n    if (typeof transaction.locktime !== \"undefined\") {\n      console.log(\"locktime \" + transaction.locktime.toString(\"hex\"));\n    }\n  }\n}\n\n/**\n */\ntype TransactionInput = {\n  prevout: Buffer,\n  script: Buffer,\n  sequence: Buffer,\n  tree?: Buffer\n};\n\n/**\n */\ntype TransactionOutput = {\n  amount: Buffer,\n  script: Buffer\n};\n\n/**\n */\ntype Transaction = {\n  version: Buffer,\n  inputs: TransactionInput[],\n  outputs?: TransactionOutput[],\n  locktime?: Buffer,\n  witness?: Buffer,\n  timestamp?: Buffer,\n  nVersionGroupId?: Buffer,\n  nExpiryHeight?: Buffer,\n  extraData?: Buffer\n};\n"]}